<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incremental Encoder Component</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0c15;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            display: flex;
            gap: 50px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .encoder-wrapper {
            text-align: center;
        }
        
        .encoder-svg {
            cursor: pointer;
            user-select: none;
        }
        
        .encoder-info {
            margin-top: 20px;
            padding: 20px;
            background: #1a1d29;
            border-radius: 10px;
            text-align: left;
            min-width: 300px;
        }
        
        .signal-display {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }
        
        .signal {
            padding: 10px 20px;
            background: #2a3142;
            border-radius: 5px;
            transition: all 0.1s;
        }
        
        .signal.high {
            background: #4a9eff;
            box-shadow: 0 0 20px #4a9eff;
        }
        
        .signal.high-z {
            background: #ff4a4a;
            box-shadow: 0 0 20px #ff4a4a;
        }
        
        .api-log {
            margin-top: 20px;
            padding: 15px;
            background: #0f1118;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        .api-config {
            margin-top: 20px;
            padding: 15px;
            background: #1a1d29;
            border-radius: 10px;
        }
        
        .api-config input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #2a3142;
            border: 1px solid #4a5568;
            border-radius: 5px;
            color: #fff;
        }
        
        .api-config button {
            padding: 8px 20px;
            background: #4a9eff;
            border: none;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .api-config button:hover {
            background: #3a8eef;
        }
        
        .pulse-diagram {
            margin: 20px 0;
            padding: 15px;
            background: #0f1118;
            border-radius: 5px;
        }
        
        .pulse-line {
            height: 30px;
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .pulse-label {
            width: 30px;
            font-weight: bold;
        }
        
        .pulse-wave {
            flex: 1;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        
        .pulse-svg {
            position: absolute;
            right: 0;
            transition: transform 0.1s linear;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="encoder-wrapper">
            <svg width="350" height="350" class="encoder-svg" id="encoder1">
                <!-- Outer ring -->
                <circle cx="175" cy="175" r="170" fill="#1a1d29" stroke="#2a3142" stroke-width="5"/>
                <circle cx="175" cy="175" r="140" fill="#2a3142" stroke="#3a4152" stroke-width="3"/>
                
                <!-- Rotation indicators (24 marks) -->
                <g id="marks">
                    <!-- Marks will be generated by JavaScript -->
                </g>
                
                <!-- Inner button -->
                <circle cx="175" cy="175" r="70" fill="#374151" stroke="#4a5568" stroke-width="2" style="cursor: pointer;"/>
                <circle cx="175" cy="175" r="65" fill="#4a5568"/>
                
                <!-- Position indicator -->
                <line x1="175" y1="35" x2="175" y2="15" stroke="#4a9eff" stroke-width="6" stroke-linecap="round" id="indicator1" transform-origin="175 175"/>
                
                <!-- Center text -->
                <text x="175" y="170" text-anchor="middle" font-size="24" font-weight="bold" fill="#fff">ENCODER</text>
                <text x="175" y="195" text-anchor="middle" font-size="14" fill="#9ca3af">24 PPR</text>
                
                <!-- Z mark (reference point) -->
                <circle cx="175" cy="15" r="4" fill="#ff4a4a" opacity="0.5" id="zeroMark1"/>
            </svg>
            
            <div class="encoder-info">
                <h3>Encoder #1 - Incremental</h3>
                <div>
                    <strong>Resolution:</strong> 24 PPR (Pulses Per Revolution)<br>
                    <strong>Position:</strong> <span id="position1">0</span>Â°<br>
                    <strong>Pulses:</strong> <span id="pulses1">0</span><br>
                    <strong>Direction:</strong> <span id="direction1">-</span><br>
                    <strong>Speed:</strong> <span id="speed1">0</span> RPM
                </div>
                
                <div class="signal-display">
                    <div class="signal" id="signalA1">A</div>
                    <div class="signal" id="signalB1">B</div>
                    <div class="signal" id="signalZ1">Z</div>
                </div>
                
                <div class="pulse-diagram">
                    <div class="pulse-line">
                        <div class="pulse-label">A:</div>
                        <div class="pulse-wave">
                            <svg class="pulse-svg" id="pulseA1" width="300" height="30">
                                <path d="M0,25 L0,25" stroke="#4a9eff" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                    </div>
                    <div class="pulse-line">
                        <div class="pulse-label">B:</div>
                        <div class="pulse-wave">
                            <svg class="pulse-svg" id="pulseB1" width="300" height="30">
                                <path d="M0,25 L0,25" stroke="#4a9eff" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="api-config">
            <h3>API Configuration</h3>
            <input type="text" id="apiEndpoint" placeholder="API Endpoint URL" value="https://api.example.com/encoder"/>
            <input type="text" id="apiKey" placeholder="API Key (optional)"/>
            <button onclick="testAPI()">Test Connection</button>
            <div class="api-log" id="apiLog">API Log will appear here...</div>
        </div>
    </div>
    
    <script>
        class IncrementalEncoder {
            constructor(id, resolution = 24) {
                this.id = id;
                this.resolution = resolution; // Pulses per revolution
                this.position = 0; // Current angle in degrees
                this.pulseCount = 0;
                this.lastPosition = 0;
                this.direction = 0; // -1 = CCW, 0 = stopped, 1 = CW
                this.signalA = false;
                this.signalB = false;
                this.signalZ = false;
                this.lastSignalA = false;
                this.lastSignalB = false;
                this.isDragging = false;
                this.startAngle = 0;
                this.speed = 0;
                this.lastTime = Date.now();
                this.pulseHistory = { A: [], B: [] };
                this.maxPulseHistory = 50;
                
                this.init();
            }
            
            init() {
                const svg = document.getElementById(`encoder${this.id}`);
                const indicator = document.getElementById(`indicator${this.id}`);
                const marks = svg.querySelector('#marks');
                
                // Generate marks
                for (let i = 0; i < this.resolution; i++) {
                    const angle = (i * 360) / this.resolution;
                    const isMain = i % 6 === 0;
                    const mark = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    mark.setAttribute('cx', 175);
                    mark.setAttribute('cy', isMain ? 45 : 50);
                    mark.setAttribute('r', isMain ? 4 : 2);
                    mark.setAttribute('fill', '#4a5568');
                    mark.setAttribute('transform', `rotate(${angle} 175 175)`);
                    marks.appendChild(mark);
                }
                
                // Mouse events
                svg.addEventListener('mousedown', (e) => this.handleStart(e));
                document.addEventListener('mousemove', (e) => this.handleMove(e));
                document.addEventListener('mouseup', () => this.handleEnd());
                
                // Touch events
                svg.addEventListener('touchstart', (e) => this.handleStart(e.touches[0]));
                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging) this.handleMove(e.touches[0]);
                });
                document.addEventListener('touchend', () => this.handleEnd());
                
                // Click to rotate
                svg.addEventListener('click', (e) => {
                    if (!this.isDragging) {
                        const rect = svg.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                        const targetDegrees = (angle * 180 / Math.PI + 90 + 360) % 360;
                        this.animateToPosition(targetDegrees);
                    }
                });
                
                // Update display
                setInterval(() => this.updateSpeed(), 100);
            }
            
            handleStart(e) {
                this.isDragging = true;
                const svg = document.getElementById(`encoder${this.id}`);
                const rect = svg.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                this.startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
            }
            
            handleMove(e) {
                if (!this.isDragging) return;
                
                const svg = document.getElementById(`encoder${this.id}`);
                const rect = svg.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                const deltaAngle = currentAngle - this.startAngle;
                
                const deltaDegrees = deltaAngle * 180 / Math.PI;
                this.rotate(deltaDegrees);
                this.startAngle = currentAngle;
            }
            
            handleEnd() {
                this.isDragging = false;
            }
            
            rotate(deltaDegrees) {
                const newPosition = (this.position + deltaDegrees + 360) % 360;
                this.updatePosition(newPosition);
            }
            
            animateToPosition(targetPosition) {
                const start = this.position;
                const distance = ((targetPosition - start + 540) % 360) - 180;
                const duration = 300;
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    const currentPosition = (start + distance * easeProgress + 360) % 360;
                    
                    this.updatePosition(currentPosition);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            updatePosition(newPosition) {
                const deltaPosition = ((newPosition - this.position + 540) % 360) - 180;
                this.position = newPosition;
                
                // Update visual
                const indicator = document.getElementById(`indicator${this.id}`);
                indicator.setAttribute('transform', `rotate(${this.position} 175 175)`);
                
                // Determine direction
                if (Math.abs(deltaPosition) > 0.1) {
                    this.direction = deltaPosition > 0 ? 1 : -1;
                    
                    // Generate pulses
                    const pulseDelta = (deltaPosition / 360) * this.resolution;
                    const pulseSteps = Math.floor(Math.abs(pulseDelta));
                    
                    for (let i = 0; i < pulseSteps; i++) {
                        this.generatePulse();
                    }
                }
                
                // Check for Z signal (reference)
                if (Math.abs(this.position) < 7.5) { // Â±7.5 degrees for 24PPR
                    if (!this.signalZ) {
                        this.signalZ = true;
                        this.pulseCount = 0; // Reset on reference
                        this.sendToAPI('reference', { signal: 'Z', position: this.position });
                    }
                } else {
                    this.signalZ = false;
                }
                
                this.updateDisplay();
            }
            
            generatePulse() {
                // Quadrature encoding - A leads B by 90Â° when rotating CW
                const pulsePosition = (this.pulseCount % this.resolution) / this.resolution * 360;
                
                this.lastSignalA = this.signalA;
                this.lastSignalB = this.signalB;
                
                // Generate quadrature signals
                this.signalA = Math.sin(pulsePosition * Math.PI / 180) > 0;
                this.signalB = Math.sin((pulsePosition - 90) * Math.PI / 180) > 0;
                
                // Detect edges
                if (this.signalA !== this.lastSignalA) {
                    this.sendToAPI('pulse', { 
                        signal: 'A', 
                        edge: this.signalA ? 'rising' : 'falling',
                        count: this.pulseCount 
                    });
                    this.addPulseToHistory('A', this.signalA);
                }
                
                if (this.signalB !== this.lastSignalB) {
                    this.sendToAPI('pulse', { 
                        signal: 'B', 
                        edge: this.signalB ? 'rising' : 'falling',
                        count: this.pulseCount 
                    });
                    this.addPulseToHistory('B', this.signalB);
                }
                
                this.pulseCount += this.direction;
            }
            
            addPulseToHistory(signal, high) {
                const history = this.pulseHistory[signal];
                history.push(high ? 5 : 25);
                if (history.length > this.maxPulseHistory * 2) {
                    history.splice(0, 2);
                }
                this.updatePulseDisplay(signal);
            }
            
            updatePulseDisplay(signal) {
                const svg = document.getElementById(`pulse${signal}${this.id}`);
                const path = this.pulseHistory[signal].map((y, i) => {
                    return `${i === 0 ? 'M' : 'L'}${i * 6},${y}`;
                }).join(' ');
                
                svg.querySelector('path').setAttribute('d', path);
                svg.style.transform = `translateX(-${Math.max(0, this.pulseHistory[signal].length * 6 - 300)}px)`;
            }
            
            updateSpeed() {
                const now = Date.now();
                const deltaTime = (now - this.lastTime) / 1000; // seconds
                const deltaAngle = ((this.position - this.lastPosition + 540) % 360) - 180;
                
                this.speed = Math.round(Math.abs(deltaAngle) / deltaTime / 6); // RPM
                
                this.lastPosition = this.position;
                this.lastTime = now;
                
                if (Math.abs(deltaAngle) < 0.1) {
                    this.speed = 0;
                    this.direction = 0;
                }
            }
            
            updateDisplay() {
                // Update text displays
                document.getElementById(`position${this.id}`).textContent = this.position.toFixed(1);
                document.getElementById(`pulses${this.id}`).textContent = this.pulseCount;
                document.getElementById(`direction${this.id}`).textContent = 
                    this.direction === 1 ? 'CW â³' : this.direction === -1 ? 'CCW â²' : '-';
                document.getElementById(`speed${this.id}`).textContent = this.speed;
                
                // Update signal indicators
                document.getElementById(`signalA${this.id}`).classList.toggle('high', this.signalA);
                document.getElementById(`signalB${this.id}`).classList.toggle('high', this.signalB);
                document.getElementById(`signalZ${this.id}`).classList.toggle('high-z', this.signalZ);
                
                // Update zero mark
                document.getElementById(`zeroMark${this.id}`).setAttribute('opacity', this.signalZ ? '1' : '0.5');
            }
            
            sendToAPI(eventType, data) {
                const endpoint = document.getElementById('apiEndpoint').value;
                const apiKey = document.getElementById('apiKey').value;
                
                if (!endpoint) return;
                
                const payload = {
                    encoderId: this.id,
                    timestamp: Date.now(),
                    eventType: eventType,
                    position: this.position,
                    pulseCount: this.pulseCount,
                    direction: this.direction,
                    speed: this.speed,
                    signals: {
                        A: this.signalA,
                        B: this.signalB,
                        Z: this.signalZ
                    },
                    ...data
                };
                
                // Log to console
                this.logAPI('POST', payload);
                
                // Send to API (uncomment for real implementation)
                /*
                fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(apiKey && { 'Authorization': `Bearer ${apiKey}` })
                    },
                    body: JSON.stringify(payload)
                })
                .then(response => response.json())
                .then(data => this.logAPI('Response', data))
                .catch(error => this.logAPI('Error', error));
                */
            }
            
            logAPI(type, data) {
                const log = document.getElementById('apiLog');
                const entry = document.createElement('div');
                const time = new Date().toLocaleTimeString();
                entry.innerHTML = `<span style="color: #6b7280">[${time}]</span> <span style="color: #4a9eff">${type}:</span> ${JSON.stringify(data, null, 2)}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
                
                // Keep log size manageable
                while (log.children.length > 50) {
                    log.removeChild(log.firstChild);
                }
            }
        }
        
        // Initialize encoder
        const encoder1 = new IncrementalEncoder(1, 24);
        
        // Test API connection
        function testAPI() {
            encoder1.sendToAPI('test', { message: 'API connection test' });
        }
    </script>
</body>
</html>
